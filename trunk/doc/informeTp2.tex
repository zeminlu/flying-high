\documentclass[10pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\author{Magni Nicol\'as, Purita Nicol\'as, Zemin Luciano R.  }
\title{Multitasker}
\begin{document}
\maketitle
\newpage
\tableofcontents
\clearpage

\section{Introducci\'on}
	\subsection{Objetivo}
		Se debe crear un sistema Operativo Multitarea, asignandoles a cada proceso un tiempo de ejecuci\'on. El multitasker corre directamente sobre memoria y montado sobre una base de un sistema monotarea. Para cargar el Sistema Operativo se utiliza el bootloader GRUB de Unix.
	\subsection{Enunciado}
Se desea implementar un Multitasker, cuyo objetivo  principal es asignar tiempo de ejecuci \'on a\ diferentes procesos en memoria. El sistema deber\'a ser implementado para plataformas Intel de 32 bits, utilizando el procesador en modo protegido. El multitasker debera ser preemptivo, es decir, cualquier tarea puede ser desalojada del microprocesador. El encargado de administrar el CPU es el scheduler el cual tomar\'a como base de tiempo la interrupci\'on de hardware INT8 correspondiente al timer tick, para realizar la asignaci\'on de tiempo ( time slot ).

	\subsection{Actividades}
		\begin{enumerate}	
			\item Se deber\'a elegir la forma en resguardar el contexto de cada tarea, se debera elejir entre las siguientes opciones
			\begin{itemize}
				\item Utilizar los TSS que provee el microprocesador Intel 386 
				\item Realizar una implementaci\'on propia de c\'odigo.
			\end{itemize}

			\item Se debera implementar dos tipos de scheduling distintos . Principalmente uno de ellos deber \'a considerar la prioridad de los procesos para asignar los slots de tiempo.

			\item El sistema deber\'a estar programado de manera que se diferencien los estados b\'asicos de Corriendo, Esperando y Listo. Por otra parte, cada proceso deber \'a tener un valor de prioridad entre 0 y 4 que indique la importancia del proceso.  Adem\'as se deber\'an demostrar el funcionamiento de los mismos con programas de prueba y se deber\'a poder corroborar el estado del proceso y el porcentaje de procesador que est\'a ocupando con la ayuda del comando top. Tambi\'en deber \'a haber un comando kill que permita matar procesos en ejecuci\'on. Tener en cuenta que kill debe matar tambi\'en a todos los hijos de ese proceso.


			\item Se debera poder tener al menos 4 terminales distintas y alternar entre ellas de manera similar a Linux.

			\item Se debera poder ejecutar diferentes tareas a trav\'es de comandos ingresados por teclado. La sintaxis de los comandos quedan a elecci\'on del desarrollador.

			\item El sistema debe tener la posibilidad de correr los mismos procesos tanto en foreground como en background. Para este ultimo se deber\'a utilizar el caracter & al igual que en UNIX.

			\item El sistema debe tener un m\'odulo de administraci\'on de memoria mediante paginaci\'on para los procesos, el mismo se encargar\'a de lo siguiente:
			\begin{itemize}
				\item Cada proceso tendr\'a su stack propio en una p\'agina, a la cual solamente  \'el tendr\'a acceso. Cada proceso podr\'a leer y escribir libremente sobre esta p\'agina pero no p\'aginas de otros procesos.
				\item Los procesos no poseer\'an un heap propio, ya que est\'an corriendo sobre la misma zona de datos del SO.
				\item Ningu\'n proceso deber\'a leer o escribir directamente ninguna variable global del SO. En caso de que haya variables globales que est\'en pensadas para ser leidas por procesos usuario, deber\'an tener una funci\'on que las copie a una zona de heap propia al proceso, simulando un system call.
			\end{itemize}
		\end{enumerate}

\section{Material entregado}
	
\section{Lineamientos de desarrolo}

\section{Kernel}
	\subsection{Objetivo}
		El \textit{Kernel} es el encargado de levantar todo el sistema operativo.
	\subsection{Esquema general}
		La funci\'on principal del \textit{Kernel} es cargar en la IDT las rutinas de atenci\'on del teclado, del timer tick y las interrupciones de la \textit{int 80}, iniciar la paginaci\'on, iniciar el multitasker e inicializar las TTYs. Ademas de todas estas inicializaciones, tambien inicia el driver de video, el m\'odulo de shared memory, los sem\'aforos y por \'ultimo habilita las entradas del Pic que correspondan para el Timer Tick y la del Teclado. 
	\subsubsection{LLamadas a Sistema}
		Para inicializar cada m\'odulo se realiza una llamada a sistema, ya que en ese instante que esta inicializando no puede perder el procesador, por lo tanto todas estas funciones antes desabilitan las interrupciones. Toda funci\'on que hayamos considerado que no pueden perder la atenci\'on hacen una llamada a sistema.
	\subsubsection{Drivers y Perisf\'ericos}

\section{Paginacion}
	\subsection{Objetivo}
		El sistema operativo debe tener un m\'odulo de paginaci\'on, por lo tanto cada proceso debe tener asociado cierta cantidad de p\'aginas. Por consecuente se debe implementar la excepci\'on correspondiente a paginaci\'on ya que el m\'odulo de administraci\'on de memoria debe verificar que un proceso no utilize p\'aginas no asignadas a \'el. Todos los procesos comparten el heap, es decir que no existen variables globales dentro del sistema operativo y en el caso que se existiesen deben estar en el heap del kernel, por lo tanto si el proceso desea obtener algun valor de alguna variable debe simular un system call y copiar la variables al heap propio del proceso.
	\subsection{Modelo}
	\subsection{Esquema general}
		Como se implement\'o un m\'odulo de administraci\'on de memoria, se debio implemantar un \textit{malloc}. Un criterio tomado es que el kernel llama una sola vez al memory map donde obtiene todo su espacio kernel,en cambio el malloc llama reiteradas veces al memory map donde se asignan las p\'aginas asociadas al heap de ese proceso. Toda la informaci\'on de las p\'aginas asignadas se encuentran en la tabla de procesos.
	\subsection{Problemas y soluciones}
		Un gran problema que obtuvimos por medio de la paginaci\'on fue que no podiamos crear mas de 4 procesos en simult\'aneo, esto se produjo ya que luego de ver reiteradas veces el c\'odigo y no darnos cuenta cual era la cause del Page Fault, decidimos seguirlo desde c\'odigo Assembler donde pudimos encontrar la raz\'on por la que se lanzaba la excepci\'on y era porque el \textbf{CR2} tenia carada una direcci\'on de una p\'agina invalida por lo tanto no estaba presente y lanzaba Page Fault. El principal problema fue en el armado de los frames de las p\'aginas, donde el algoritmo no contemplaba un caso donde habia que dar de baja un frame, levantar otro y asi consecutivamente. Luego de una gran reestructuraci\'on de nuestro sistema se nos paso asignar los nuevos valores definidos en \textit{defs.h} para llevar a cabo la paginaci\'on, por lo tant retornaba direcciones no deseadas.
	\subsection{Limitaciones}
		Como no se utiliz\'o segmentacion de p\'aginas, el malloc siempre retornaba p\'aginas contiguas y no se almacenaba ningun registro sobre segmentos otorgados.

\section{File System} 
	\subsection{Modelado}
		Se implment\'o una simulaci\'on de un File System, pero unicamente teniendo los pseudoarchivos \textit{STDIN} y \textit{STDOUT}. Cada proceso tiene almacenado en su estructura estos pseudoarchivos.
	\subsection{Esquema general}
	\subsection{Problemas y soluciones}
	\subsection{Limitaciones}

\section{TTY}
	\subsection{Objetivo}
		El objetivo era implementar al menos 4 ttys y comenzar a dividir las tareas a realizar. Como el sistema en el cual esta basado el sistema operativo multitarea era mono tarea, el encargado de todas las operaciones sobre el imprimir, parsear caracteres, etc era el driver de video, se modific\'o para que las ttys sean las encargadas de hacer ese labor.
	\subsection{Modelo}
		El model dise√±ado para las ttys basicamente es que cada ttys tiene su \textit{STDOUT} donde mantiene el estado de la pantalla y un \textit{STDIN} tambien. El principal objetivo de la tty es traducir a un lenguaje indicado, de acuerdo al lenguaje que este manejando ese proceso. Los tipos de lenguajes que soporta son \textbf{Can\'onico} y \textbf{Crudo}, donde la principal diferencia es que el modo Crudo imprime el caracter directamente sin ser parseado y el Can\'onico realiza un parsea previo de los caracteres de control. En el stdout de la tty se almacena unicamente el lenguaje de la shell, es decir ya parseado.
	\subsection{Esquema general}
		Para cada TTY se creo una estructura del tipo \textit{FILE} donde se almacenan sus respectivos \textit{STDIN} y \textit{STDOUT}. Ademas la TTY almacena su \textit{id}, si se realizo un scroll y los desplazamientos realizados sobre el stdout ya se de escritura como de lectura. Como ya se mencion\'o anteriormente utilizamos dos modos de lenguajes que puede traducir la tty, el can\'onico y el crudo, el primer lenguaje mencionado parsea los caracteres y lo coloca en el \textit{stdout} de la tty indicada, existen excepciones como que cuando se ingresa un \textit{Newline} se baja todos los caracteres ingresados en el \textit{STDIN} y se los pasa a la Shell para que ella luego los procese como un comando. \\
		Cuando se cambia de TTY es decir que se oprimio alguna de los F (entre el F1 y el F7), se realiza un cambio de tty, por lo tanto se llama a la funci\'on que refresca el \textit{STDOUT} y lo imprime en pantalla y salva las variables utilizadas para escribir y leer en la TTY que corresponda y carga las nuevas variables. Las teclas Fx, siendo x alg\'un n\'umero entre 1 y 7, no se ingresa en un ningun buffer de la TTY sino que el refresh del teclado llama a la funci\'on encargada de cambiar de TTY.\\
	\subsection{Problemas y soluciones}
		Se obtuvieron muchos problemas con la TTY ya que a medida que se iba leyendo algo o preguntando algo, nos dabamos cuenta que teniamos que mejorarlo por lo tanto, las TTYs sufieron muchos cambios.\\
		El primer problema que nos surg\'io fue el tema de los lenguajes que manejaba la TTY, el tema de los buffers. En un principio teniamos un \'unico \textit{STDIN}, por lo que tuvimos que cambiarlo y asignarles un buffer \textit{STDIN} a cada TTY. \\
		Otro problema con esto fue la diferenciaci\'on entre el \textit{STDIN} y \textit{stdin}, donde para nosotros el \textit{stdin} es la entrada est\'andar del proceso que estaba corriendo y no necesariamente es el que esta en foco en la TTY actual, menos aun podria serlo si es una shell que esta dormida. Por lo tanto se tuvieron que modificar los write y read para escriban sobre un \textit{stdin} y \textit{stdout} indicado.
		Un problema de no gran envergadura fue el manejo de los indices, ya que en un principio se utiliz\'o dos variables de desplazamiento unicamente y se incrementaba de a un paso o en el caso que fuese un caracter de control se desplazaba lo indicado por ese caracter, pero por cuestiones de simplicidad se decidi\'o utilizar una varible que me indica la cantidad de caracteres que escribi\'o en el \textit{STDOUT} de la TTY, una variable que me dice la fila en la cual se encuentra y una variable para la columna. Del mismo modo para las variables de lectura, se siguio el mismo criterio.
	\subsection{Limitaciones}
		
\section{Procesos}
	\subsection{Objetivo}
	\subsection{Modelado}
	\subsection{Esquema general}
	\subsection{Creacion de procesos}
	\subsection{Herencia de TTY's}
	\subsection{Muerte de un proceso}
	\subsection{Procesos ejecutados en background}
	\subsection{Procesos especiales}
	\subsubsection{Top}
	\subsection{Problemas y soluciones}
	\subsection{Limitaciones}
	\subsection{Problemas y soluciones}
	\subsection{Limitaciones}


\section{Multitasker}
	\subsection{Objetivo}
	\subsection{Modelo}
	\subsection{Esquema general}
	\subsection{Problemas y soluciones}
	\subsection{Limitaciones}

\section{Scheduler}
	\subsection{RPG}
	\subsubsection{Modelo}
		Implementar un algoritmo basado en juegos RPG. El algoritmo consite en asignarle un puntaje a un proceso en cada llamado del scheduler. Cuando un proceso llega al puntaje designado como m\'aximo se lo agrega a la lista de procesos listos para ejecutar. Luego se verifica que proceso es el que tiene mas antiguedad. Una vez devuelto el proceso a procesar, se reinicia el contador de puntos rpg y la antiguedad.
	\subsubsection{Problemas y soluciones}
		Principalmente tuvimos un problema manejando la antiguedad de los procesos, luego decidimos tomar una funci\'on de evaluaci\'on que nos permite ir pasando por todos los procesos, que no alcanzen inmediatamente el puntaje m\'aximo de rpg, para luego ser atendido.
	\subsubsection{Limitaciones}
		La funci\'on de evaluaci\'on en el caso de que se aumente la cantidad de procesos o disminuya habria que cambiarla, porque es en funci\'on de prioridades y cantidad m\'axima de procesos, tambien habria que modificar el puntaje m\'aximo de rpg a alcanzar

\subsection{Round-Robin}
	\subsubsection{Objetivo}
		Implementar un algoritmo del tipo Round Robin. Basicamente se comporta como una lista circular donde se van devolviendo todos los procesos que esten en estado \textbf{READY} en el orden que se encuentran en la tabla de procesos.
	\subsubsection{Modelo}
		El modelo tomado es el siguiente, en el que la gran mayor\'ia debe utilizar. Se toma la lista de procesos y se la recorre en forma lineal verificando si algun proceso se encuentra listo para ser atendido, en el caso de que haya alguno se lo devuelvo y en la pr\'oxima llamada se arranca a recorrer desde esa posicion y se realiza el mismo recorrido ya explicado anteriormente.
	\subsubsection{Problemas y soluciones}
		En un principio el algoritmo se quedaba en un loop infinito ya que buscasa desde init y como siempre estaba listo lo devolvia y a veces no retornaba o era interrumpido. Por lo tanto una soluci\'on fue llamar al scheduler en caso de que haya algun proceso para correr distinto de init. En un principio teniamos problemas con el algoritmo porque compilabamos con la opci\'on de optimizaci\'on y se agregaban funciones en el c\'odigo que no queriamos, luego de darnos cuenta de ese error comenz\'o a andar el algoritmo.
	\subsubsection{Limitaciones}
		El algoritmo en si no maneja el tema de prioridades, sino en el orden el cual fueron creados los procesos. Se podria hacer que la creaci\'on de procesos los inserte en forma ordenada en la tabla de procesos por lo tanto el algortimo \textit{Round Robin} de alguna forma estar\'ia teniendo en cuenta el tema de prioridades.

\subsection{IPCs Implementaciones}
	\subsubsection{Shared memory}
		Se implement\'o un IPC basado en Shared memory, donde la cantidad de shared memory esta definida por un define. Se decidi\'o utilizar la estructura que utiliza System Five para la shared memory y Posix para los sem\'aforos. Cada shared memory ya tiene asociado un sem\'aforo y la cantidad de frames que tiene desiganados para utilizar.
	\subsubsection{Objetivo}
		Implementar un juego en donde se pueda verificar la comunicaci\'on entre los dos procesos mediante un IPC, en nuestro caso \textbf{Shared Memory}.
	\subsubsection{Modelo}
		En un principio se decidi\'o implementar como juego un Chat entre varias shells, pero finalmente se eligi\'o hacer la batalla naval con cierta restricciones. La creaci\'on de barcos se genera en forma aleatoria, es decir que se implement\'o un random muy b\'asico donde usa un polinomio de grado 1 y como semilla utiliza los tick realizados por el timer tick hasta el momento. El juego es de dos personas unicamente, como la tradicional batalla naval.
	\subsubsection{Esquema general}
		La forma que se nos ocurrio para comunicar los dos procesos es que cuando crea ese procesa el juego te da la opci\'on de ser host o unirte a una partida ya creada. Por lo tanto cuando creo el primer proceso puedo elegir entre ser host o unirme a una partida ya creada, la forma de unirse es que el host cuando crea se le muestra en pantalla el ID de la shared memory creada, por lo tanto el jugador 2 debe ingresar ese id para unirse a esa partida. Una vez ya pasados los primeros pasos comienza el juego. La comunicaci\'on que viaja por la shared memory son las posiciones del tablero en donde se ubicaron las bombas. En un principio se habia dicho de poner el tablero de cada jugador en la shared memory y que el jugador escriba directamente sobre esa posicion, pero nos dimos cuenta que en verdad la informaci\'on que necesitan los dos son las posiciones del tablero para cada uno actualizar donde fue puesta la bomba y verificar si le dio a algun barco o si fue agua. \\
		Cada vez que un usuario ingresa una posici\'on en donde desea ubicar la bomba se bloquea el tablero y una vez enviado el mensaje se desbloquea. De esta forma evitamos que los dos jugadores pongan en el mismo instante dos posiciones distintas y se mezclen sus ubicaciones.
	\subsubsection{Problemas y limitaciones}
		Un problema fue tomar la decisi\'on de ubicar los barcos, si el usuario los podia ubicar o si lo generabamos nosotros, se opto por la segunda y los barcos pueden estar unicamente verticales y horizontales, no diagonales. \\
		Otro problema que nos surgio fue que los sem\'aforos se quedaban esperando pero se seguia imprimiendo el tablero esperando la conexi\'on de algun usuario al juego, por lo tanto decidimos modificar los sem\'aforos para que se queden esperando y no pueda realizar otra cosa, entonces cuando alguien ingresa una posici\'on se refresca el tablero.  

\subsection{Conclusi\'on}

\subsection{Bibliograf'ia y fuentes}

\end{document}