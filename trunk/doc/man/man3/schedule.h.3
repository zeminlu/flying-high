.TH "inc/schedule.h" 3 "18 May 2010" "Version 1.0" "flying-high" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/schedule.h \- 
.PP
The OS scheduler module.  

.SH SYNOPSIS
.br
.PP
\fC#include 'types.h'\fP
.br
\fC#include 'uMalloc.h'\fP
.br
\fC#include 'video_driver.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBROUND_ROBIN\fP   1"
.br
.ti -1c
.RI "#define \fBRPG\fP   2"
.br
.ti -1c
.RI "#define \fBMAX_RPG\fP   10"
.br
.ti -1c
.RI "#define \fBevaluate\fP(x)   ((x * 0.75) + ((x+2)/MAX_PROCESS) * 100)"
.br
.ti -1c
.RI "#define \fBMAX\fP(a, b)   ((a > b) ? a : b)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBprocess_t\fP * \fBrpgSchedule\fP ()"
.br
.RI "\fIThis function simulates the RPG scheduling. What this algorithm does, is that when a process achieves the maximum value of RPG, it adds it to a queue. After that the functions just find the oldest process that is waiting to be attended. \fP"
.ti -1c
.RI "\fBprocess_t\fP * \fBgetNextTask\fP (void)"
.br
.RI "\fIThis function returns the next task that should be attended. \fP"
.ti -1c
.RI "int \fBcheckWhatAreReady\fP (void)"
.br
.RI "\fIThis function checks what processes are ready using the RPG Algorithim. \fP"
.ti -1c
.RI "void \fBincreaseRPGCounter\fP (void)"
.br
.RI "\fIThis function increases the current rpg value of each process. \fP"
.ti -1c
.RI "void \fBchangeAlgorithimSchedule\fP (void)"
.br
.RI "\fIThis function changes the Algorithm variable, if the current algorithm is RoundRobin it changes to RPG and viceversa. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The OS scheduler module. 

\fBAuthor:\fP
.RS 4
Luciano Zemin, Nicolás Magni, Nicolás Purita 
.RE
.PP

.PP
Definition in file \fBschedule.h\fP.
.SH "Define Documentation"
.PP 
.SS "#define evaluate(x)   ((x * 0.75) + ((x+2)/MAX_PROCESS) * 100)"
.PP
Definition at line 20 of file schedule.h.
.SS "#define MAX(a, b)   ((a > b) ? a : b)"
.PP
Definition at line 21 of file schedule.h.
.SS "#define MAX_RPG   10"
.PP
Definition at line 18 of file schedule.h.
.SS "#define ROUND_ROBIN   1"
.PP
Definition at line 16 of file schedule.h.
.SS "#define RPG   2"
.PP
Definition at line 17 of file schedule.h.
.SH "Function Documentation"
.PP 
.SS "void changeAlgorithimSchedule (void)"
.PP
This function changes the Algorithm variable, if the current algorithm is RoundRobin it changes to RPG and viceversa. 
.PP
Definition at line 111 of file schedule.c.
.SS "int checkWhatAreReady (void)"
.PP
This function checks what processes are ready using the RPG Algorithim. \fBReturns:\fP
.RS 4
the index of table process 
.RE
.PP

.PP
Definition at line 82 of file schedule.c.
.SS "\fBprocess_t\fP * getNextTask (void)"
.PP
This function returns the next task that should be attended. \fBReturns:\fP
.RS 4
The next process
.RE
.PP
Use: 
.PP
.nf
                     changeContext(getNextTask());

.fi
.PP
 
.PP
Definition at line 69 of file schedule.c.
.SS "void increaseRPGCounter (void)"
.PP
This function increases the current rpg value of each process. 
.PP
Definition at line 97 of file schedule.c.
.SS "\fBprocess_t\fP * rpgSchedule ()"
.PP
This function simulates the RPG scheduling. What this algorithm does, is that when a process achieves the maximum value of RPG, it adds it to a queue. After that the functions just find the oldest process that is waiting to be attended. \fBReturns:\fP
.RS 4
The process to be attended
.RE
.PP
Use: 
.PP
.nf
                        if( ALGORITHIM == RPG )
                                return rpgSchedule();

.fi
.PP
 
.PP
Definition at line 57 of file schedule.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for flying-high from the source code.
