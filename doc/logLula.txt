*ponemos en la funcion  increaseKernelDepth, se llama al funcion cli , para que no lo tengamos que hacer en cada Sys CAll. Y como no se anidan no hay problema.

El armado del stock frame para cada proceso supuso un estudio detalladisimo del mismo, dado que en la función multitasker, donde una vez seleccionado el siguiente proceso, se debía realizar el cambio de contexto mediante el cambio de esp y ebp, los mismos, que pasarían a ser los del proceso siguiente, deberían estar construidos de manera tal que al retornar del multitasker, el stack se recuperase correctamente de los movimientos que había realizado antes de cambiar el contexto, y así luego del retorno, en el handler de la interrupción, al realizar el pop de los registros backupeados y realizar iret, el microprocesador tomase como dirección de retorno, segmento de código e eflags, los correspondientes al comienzo del proceso elegido.

Tuvimos un problema al armar el stock frame de cada proceso, dado que inicialmente utilizábamos en compilación la opción -O araoptimizacion, el compilador en la función del multitasker hacia una compilación incline de una función que utiliza la misma, llamada freeterminatedproceses, la cual requería 3 registros para trabajar, y además un espacio para variables locales mayor. Debdio a eso, el compilador para la función  ultitasker reservaba un tamaño para las mismas mucho mayor que el estándard de 0x000018, y por ello, cuando uno arma el stock frame, en el esp tiene que reservar dicho tamaño para que cuando en el multitasker se cambie el stock, al salir la función, la misma acomode el stock pointer adecuadamente para que obtenga la dirección de retorno correcta, y así poder luego en el handler de la int-08 con el iret "retornar" al nuevo proceso seleccionado por el multitasker. Para solucionar esto, se realizo un seguimiento linea a linea de la salida de assembler de la copulación de la función del multitasker, se encontró esta compilación incline, y luego se la desactivo para verificar que solo se reservara 0x000018, y así definir el tamaño para variables locales de esa forma, y poder armar correctamente el stock frame.

El round robín scheduler trajo algunos problemas e el algoritmo, dado que en un principio el algoritmo quedaba en un lop infinito, ya que no debe buscar al proceso  init como proceso posible, y solo invocarlo cuando ningún otro proceso pueda ser seleccionado. Mediante una serie de impresiones en pantalla se verifico la mala implementación de este algoritmo y pudo ser corregida.

Los cli y sti fueron también un problema. Dado que no son anidables, al comienzo fue complicado ver donde deberían utilizarse los clli y sti correspondientes para lograr una atomicidad apropiada par los manejos de interrupciones. Luego de un extenso análisis, se corroboro que a pesar de al comienzo de un manejador de interrupción, deshabitar las interrupciones mediante cli, esto no implicaba que al retornar las mismas siguieran deshabitadas, dado que se recuperan los eflags del proceso que fue interrumpido, y en dichos eflags las interrupciones seguían habilitadas. Por ello, se concluyo que sti no es necesario utilizarlo dado que consecutivas llamadas a interrupciones, sin retornar de la primera, no requieren de ningún sti dado que deben ser todas atómicas, y que se restituirían las mismas en cuanto la primera retornase. Es por ello que Sti solo se utiliza en el modulo de arranque del kernel para poder cargar correctamente el vector de interrupciones. Los cambios de contextos por si solos logran restaurar la habilitación de interrupciones al recuperar sus eflags. Antes de todo esto, se intento incluir cli y sti en la función increaseKernelDepth, dado que en la misma, encargada de setear en presente las paginas del heap del kernel cuando una interrupción es llamada, y manejar bien las consecutivas indexaciones hacia el kernel, se pone en presente dichas paginas solo en la primer llamada a increase, y solo se deshabitan en la ultima llamada a decrease, siempre y cuando la cantidad de increase sea igual a la de decrease. Si bien posicionar cli en increase no resultaba un problema, si lo resultaba ser el sti, dado que la imposibilidad de anidacion de sli y cti arruinaban la lógica.

Tuvimos un problema al invocar la llamada a increase y decrease en los maneadores, dado que los mismos utilizan algunos registros, y antes de llamarlos se debía realizar un pusheo de los mismos, y recuperarlos a su retorno. Esto tomo bastante tiempo dado que es algo muy sutil que no debe ser tomado a la ligera. Por suerte se logro encontrar este error y salvar los registros pertinentes.

Un gran problema fue que no podiamos crear mas de 4 procesos, al crear el 5to, tiraba page fault la creacion de su stack frame. Tomo mucho tiempo encontrar la razon, tuvimos que seguir el codigo en assembler con el debugger de bochs para ver que direccion estaba intentando acceder. Eso se pudo hacer gracias a qeu en el CR2 queda la direccion que se quiso acceder que tiro page fault. Por ello notamos que estaba intentando acceder a cualquier lugar. Se debuggeo toda la paginacion y se encontro que el armado de los frames de paginas que nosotros utilizamos, tenia un error en el algoritmo, y dicha revision llevo a encontrar errores en la funcion que pone y saca la presencia de los frames, y ademas en el archivo defs.h donde figuran la mayoria de los defines del sistema operativo, que, par anuestra sorpresa, tenia valores viejisiimos que no concordaban con la estructura actual del sistema. Una vez correjido dichos valores y funciones, la paginacion fue finalmente correcta y pudo crearese tantos procesos como se quiso.

Un gran problema fue el hecho de darle, ante un newline, la linea que la tty acababa de procesar al proceso que correspondiera, el cual seria el proceso en foco en la tty en foco. El problema era que en la funcion que se encargaba de eso, se utilizaba un write en STDIN, y para nosotros, stdin es el stdin del proceso que esta corriendo, que no necesariamente es el que esta en foco en la tty actual. Menos aun podria serlo si es una shell que esta dormida. por ese motivo, se tuvo que implementar una funcion que devolviera el stdin del proceso en foco en la tty en foco para asi poder darle la informacion.

Existe un problema con la shell que no pudimos resolver aun...consiste en que la reimplementacion del manejo de su buffer, que ahora son tantos como shells existan, falla en algun punto y por ello no procesa los comandos. ACTUALIZAR ESTO CUANDO SE SOLUCIONEEEE!!!

Tuve que implementar fread y fwrite para poder escribir en un stream especifico y no unicamente poder hacer write sobre los streams del running process. Ahora con esto los putlines van a andar.